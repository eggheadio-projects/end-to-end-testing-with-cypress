(function() {
  var _, anyUnderscoredValuePairs, backup, coerce, config, cwd, everythingAfterFirstEqualRe, hasStrayEndQuote, minimist, normalizeBackslash, normalizeBackslashes, parseNestedValues, path, removeLastCharacter, whitelist,
    slice = [].slice;

  _ = require("lodash");

  path = require("path");

  minimist = require("minimist");

  coerce = require("./coerce");

  config = require("../config");

  cwd = require("../cwd");

  whitelist = "appPath execPath apiKey smokeTest getKey generateKey runProject project spec ci record updating ping key logs clearLogs returnPkg version mode autoOpen removeIds headed config exitWithCode hosts browser headless outputPath group groupId exit".split(" ");

  whitelist = whitelist.concat(config.getConfigKeys());

  everythingAfterFirstEqualRe = /=(.+)/;

  hasStrayEndQuote = function(s) {
    var quoteAt;
    quoteAt = s.indexOf('"');
    return quoteAt === s.length - 1;
  };

  removeLastCharacter = function(s) {
    return s.substr(0, s.length - 1);
  };

  normalizeBackslash = function(s) {
    if (hasStrayEndQuote(s)) {
      return removeLastCharacter(s);
    } else {
      return s;
    }
  };

  normalizeBackslashes = function(options) {
    var pathProperties;
    pathProperties = ["runProject", "project", "appPath", "execPath"];
    pathProperties.forEach(function(property) {
      if (options[property]) {
        return options[property] = normalizeBackslash(options[property]);
      }
    });
    return options;
  };

  parseNestedValues = function(vals) {
    return _.chain(vals).split(",").map(function(pair) {
      return pair.split(everythingAfterFirstEqualRe);
    }).fromPairs().mapValues(coerce).value();
  };

  backup = function(key, options) {
    return options["_" + key] = options[key];
  };

  anyUnderscoredValuePairs = function(val, key, obj) {
    var v;
    if (v = obj["_" + key]) {
      return v;
    }
    return val;
  };

  module.exports = {
    toObject: function(argv) {
      var c, envs, hosts, op, options, p, ref, ro, whitelisted;
      options = minimist(argv, {
        alias: {
          "app-path": "appPath",
          "exec-path": "execPath",
          "api-key": "apiKey",
          "smoke-test": "smokeTest",
          "remove-ids": "removeIds",
          "get-key": "getKey",
          "new-key": "generateKey",
          "clear-logs": "clearLogs",
          "run-project": "runProject",
          "return-pkg": "returnPkg",
          "auto-open": "autoOpen",
          "headless": "isTextTerminal",
          "exit-with-code": "exitWithCode",
          "reporter-options": "reporterOptions",
          "output-path": "outputPath",
          "group-id": "groupId"
        }
      });
      whitelisted = _.pick.apply(_, [argv].concat(slice.call(whitelist)));
      options = _.chain(options).defaults(whitelisted).mapValues(coerce).value();
      if (options.updating && !options.appPath) {
        ref = options._.slice(-2), options.appPath = ref[0], options.execPath = ref[1];
      }
      if (hosts = options.hosts) {
        backup("hosts", options);
        options.hosts = parseNestedValues(hosts);
      }
      if (envs = options.env) {
        backup("env", options);
        options.env = parseNestedValues(envs);
      }
      if (ro = options.reporterOptions) {
        backup("reporterOptions", options);
        options.reporterOptions = parseNestedValues(ro);
      }
      if (c = options.config) {
        backup("config", options);
        c = parseNestedValues(c);
        options.config = c;
        _.extend(options, config.whitelist(c));
      }
      options = normalizeBackslashes(options);
      if (p = options.project || options.runProject) {
        options.projectPath = path.resolve(cwd(), p);
      }
      if (op = options.outputPath) {
        options.outputPath = path.resolve(cwd(), op);
      }
      if (options.runProject) {
        options.run = true;
      }
      if (options.smokeTest) {
        options.pong = options.ping;
      }
      return options;
    },
    toArray: function(obj) {
      var ref;
      if (obj == null) {
        obj = {};
      }
      return (ref = _.chain(obj).mapValues(anyUnderscoredValuePairs)).pick.apply(ref, whitelist).mapValues(function(val, key) {
        return "--" + key + "=" + val;
      }).values().value();
    }
  };

}).call(this);
