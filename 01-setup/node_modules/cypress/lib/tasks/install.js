'use strict';

var _templateObject = _taggedTemplateLiteral(['\n    Cypress ', ' is already installed. Skipping installation.\n  '], ['\n    Cypress ', ' is already installed. Skipping installation.\n  ']),
    _templateObject2 = _taggedTemplateLiteral(['\n    Pass the ', ' option if you\'d like to reinstall anyway.\n  '], ['\n    Pass the ', ' option if you\'d like to reinstall anyway.\n  ']),
    _templateObject3 = _taggedTemplateLiteral(['\n      It looks like you\'ve installed Cypress globally.\n\n      This will work, but it\'s not recommended.\n\n      The recommended way to install Cypress is as a devDependency per project.\n\n      You should probably run these commands:\n\n        - ', '\n        - ', '\n    '], ['\n      It looks like you\\\'ve installed Cypress globally.\n\n      This will work, but it\'\\s not recommended.\n\n      The recommended way to install Cypress is as a devDependency per project.\n\n      You should probably run these commands:\n\n        - ', '\n        - ', '\n    ']),
    _templateObject4 = _taggedTemplateLiteral(['\n          Forcing a binary version different than the default.\n\n          The CLI expected to install version: ', '\n\n          Instead we will install version: ', '\n\n          Note: there is no guarantee these versions will work properly together.\n        '], ['\n          Forcing a binary version different than the default.\n\n          The CLI expected to install version: ', '\n\n          Instead we will install version: ', '\n\n          Note: there is no guarantee these versions will work properly together.\n        ']),
    _templateObject5 = _taggedTemplateLiteral(['\n      Installed version ', ' does not match needed version ', '.\n    '], ['\n      Installed version ', ' does not match needed version ', '.\n    ']);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _ = require('lodash');
var path = require('path');
var chalk = require('chalk');
var Listr = require('listr');
var verbose = require('@cypress/listr-verbose-renderer');

var _require = require('common-tags'),
    stripIndent = _require.stripIndent;

var debug = require('debug')('cypress:cli');
var Promise = require('bluebird');
var fs = require('../fs');
var download = require('./download');
var util = require('../util');
var info = require('./info');
var unzip = require('./unzip');
var logger = require('../logger');
var la = require('lazy-ass');
var is = require('check-more-types');

var alreadyInstalledMsg = function alreadyInstalledMsg(installedVersion, needVersion) {
  logger.log(chalk.yellow(stripIndent(_templateObject, chalk.cyan(needVersion))));

  logger.log();

  logger.log(chalk.gray(stripIndent(_templateObject2, chalk.white('--force'))));
};

var displayCompletionMsg = function displayCompletionMsg() {
  logger.log();

  // check here to see if we are globally installed
  if (util.isInstalledGlobally()) {
    // if we are display a warning
    logger.warn(stripIndent(_templateObject3, chalk.cyan('npm uninstall -g cypress'), chalk.cyan('npm install --save-dev cypress')));

    return;
  }

  logger.log(chalk.yellow('You can now open Cypress by running:'), chalk.cyan(path.join('node_modules', '.bin', 'cypress'), 'open'));

  logger.log();

  logger.log(chalk.yellow('https://on.cypress.io/installing-cypress'));
};

var downloadAndUnzip = function downloadAndUnzip(version) {
  var options = {
    version: version

    // let the user know what version of cypress we're downloading!
  };var message = chalk.yellow('Installing Cypress ' + chalk.gray('(version: ' + version + ')'));
  logger.log(message);
  logger.log();

  var progessify = function progessify(task, title) {
    // return higher order function
    return function (percentComplete, remaining) {
      percentComplete = chalk.white(' ' + percentComplete + '%');

      // pluralize seconds remaining
      remaining = chalk.gray(remaining + 's');

      util.setTaskTitle(task, util.titleize(title, percentComplete, remaining), rendererOptions.renderer);
    };
  };

  // if we are running in CI then use
  // the verbose renderer else use
  // the default
  var rendererOptions = {
    renderer: util.isCi() ? verbose : 'default'
  };

  var tasks = new Listr([{
    title: util.titleize('Downloading Cypress'),
    task: function task(ctx, _task) {
      // as our download progresses indicate the status
      options.onProgress = progessify(_task, 'Downloading Cypress');

      return download.start(options).then(function (_ref) {
        var filename = _ref.filename,
            downloaded = _ref.downloaded;

        // save the download destination for unzipping
        ctx.downloadDestination = filename;
        ctx.downloaded = downloaded;

        util.setTaskTitle(_task, util.titleize(chalk.green('Downloaded Cypress')), rendererOptions.renderer);
      });
    }
  }, {
    title: util.titleize('Unzipping Cypress'),
    task: function task(ctx, _task2) {
      // as our unzip progresses indicate the status
      options.downloadDestination = ctx.downloadDestination;
      options.onProgress = progessify(_task2, 'Unzipping Cypress');

      return unzip.start(options).then(function () {
        util.setTaskTitle(_task2, util.titleize(chalk.green('Unzipped Cypress')), rendererOptions.renderer);
      });
    }
  }, {
    title: util.titleize('Finishing Installation'),
    task: function task(ctx, _task3) {
      var downloadDestination = options.downloadDestination,
          version = options.version;

      la(is.unemptyString(downloadDestination), 'missing download destination', options);
      la(is.bool(ctx.downloaded), 'missing downloaded flag', ctx);

      var removeFile = function removeFile() {
        debug('removing zip file %s', downloadDestination);
        return fs.removeAsync(downloadDestination);
      };
      var skipFileRemoval = function skipFileRemoval() {
        debug('not removing file %s', downloadDestination);
        debug('because it was not downloaded (probably was local file already)');
        return Promise.resolve();
      };
      var cleanup = ctx.downloaded ? removeFile : skipFileRemoval;

      return cleanup().then(function () {
        var dir = info.getPathToUserExecutableDir();
        debug('finished installation in', dir);

        util.setTaskTitle(_task3, util.titleize(chalk.green('Finished Installation'), chalk.gray(dir)), rendererOptions.renderer);

        return info.writeInstalledVersion(version);
      });
    }
  }], rendererOptions);

  // start the tasks!
  return tasks.run();
};

var start = function start() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (process.env.CYPRESS_SKIP_BINARY_INSTALL) {
    logger.log(chalk.yellow('Skipping binary installation. Env var \'CYPRESS_SKIP_BINARY_INSTALL\' was found.'));
    return Promise.resolve();
  }

  debug('installing with options %j', options);

  _.defaults(options, {
    force: false
  });

  var needVersion = util.pkgVersion();

  // let this env var reset the binary version we need
  if (process.env.CYPRESS_BINARY_VERSION) {
    var envVarVersion = process.env.CYPRESS_BINARY_VERSION;

    // if this doesn't match the expected version
    // then print warning to the user
    if (envVarVersion !== needVersion) {
      debug('using env var CYPRESS_BINARY_VERSION %s', needVersion);
      logger.log(chalk.yellow(stripIndent(_templateObject4, chalk.cyan(needVersion), chalk.cyan(envVarVersion))));
      logger.log('');

      // reset the version to the env var version
      needVersion = envVarVersion;
    }
  }

  return info.getInstalledVersion().catchReturn(null).then(function (installedVersion) {
    debug('installed version is', installedVersion, 'version needed is', needVersion);

    if (options.force) {
      return info.clearVersionState();
    }

    if (installedVersion === needVersion) {
      // our version matches, tell the user this is a noop
      alreadyInstalledMsg(installedVersion, needVersion);

      return false;
    }

    if (!installedVersion) {
      return info.clearVersionState();
    }

    logger.warn(stripIndent(_templateObject5, chalk.cyan('(' + installedVersion + ')'), chalk.cyan('(' + needVersion + ')')));

    logger.log();
  }).then(function (ret) {
    // noop if we've been told not to download
    if (ret === false) {
      return;
    }

    // TODO: what to do about this? let's just not support it
    // let needVersion be a path to a real cypress binary
    // instead of a version we download from the internet
    return fs.statAsync(needVersion).then(function () {
      logger.log('Installing local Cypress binary from %s', needVersion);

      // TODO: move all this shit, it doesn't work as is now anyway
      return unzip.start({
        zipDestination: needVersion,
        destination: info.getInstallationDir(),
        executable: info.getPathToUserExecutableDir()
      }).then(function () {
        return info.writeInstalledVersion('unknown');
      });
    }).catch(function () {
      debug('preparing to download and unzip version', needVersion);

      return downloadAndUnzip(needVersion).then(function () {
        // wait 1 second for a good user experience
        return Promise.delay(1000);
      }).then(displayCompletionMsg);
    });
  });
};

module.exports = {
  start: start
};